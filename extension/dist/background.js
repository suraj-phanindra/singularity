const m="SingularityDB";const s="facts",u="conversations";let f=null;async function w(){return new Promise((t,r)=>{const e=indexedDB.open(m,1);e.onerror=()=>r(e.error),e.onsuccess=()=>{f=e.result,t(f)},e.onupgradeneeded=n=>{const c=n.target.result;if(!c.objectStoreNames.contains(s)){const o=c.createObjectStore(s,{keyPath:"id",autoIncrement:!0});o.createIndex("platform","platform",{unique:!1}),o.createIndex("timestamp","timestamp",{unique:!1}),o.createIndex("category","category",{unique:!1})}if(!c.objectStoreNames.contains(u)){const o=c.createObjectStore(u,{keyPath:"id",autoIncrement:!0});o.createIndex("platform","platform",{unique:!1}),o.createIndex("timestamp","timestamp",{unique:!1})}}})}async function i(){return f||await w(),f}async function h(t){const r=await i();return new Promise((e,n)=>{const a=r.transaction([s],"readwrite").objectStore(s).add(t);a.onsuccess=()=>e(a.result),a.onerror=()=>n(a.error)})}async function p(t){const r=await i();return new Promise((e,n)=>{const a=r.transaction([u],"readwrite").objectStore(u).add(t);a.onsuccess=()=>e(a.result),a.onerror=()=>n(a.error)})}async function x(){const t=await i();return new Promise((r,e)=>{const o=t.transaction([s],"readonly").objectStore(s).getAll();o.onsuccess=()=>r(o.result),o.onerror=()=>e(o.error)})}async function b(t=10){const r=await i();return new Promise((e,n)=>{const d=r.transaction([s],"readonly").objectStore(s).index("timestamp").openCursor(null,"prev"),l=[];d.onsuccess=S=>{const y=S.target.result;y&&l.length<t?(l.push(y.value),y.continue()):e(l)},d.onerror=()=>n(d.error)})}async function C(){const t=await i();return new Promise((r,e)=>{const o=t.transaction([s],"readonly").objectStore(s).count();o.onsuccess=()=>r(o.result),o.onerror=()=>e(o.error)})}async function k(t){const r=await i();return new Promise((e,n)=>{const a=r.transaction([s],"readwrite").objectStore(s).delete(t);a.onsuccess=()=>e(),a.onerror=()=>n(a.error)})}async function E(){const t=await i();return new Promise((r,e)=>{const n=t.transaction([s,u],"readwrite"),c=n.objectStore(s),o=n.objectStore(u);c.clear(),o.clear(),n.oncomplete=()=>r(),n.onerror=()=>e(n.error)})}const g="http://localhost:8000";console.log("[Singularity] Background service worker initialized");w().then(()=>{console.log("[Singularity] IndexedDB initialized")}).catch(t=>{console.error("[Singularity] Failed to initialize IndexedDB:",t)});chrome.runtime.onMessage.addListener((t,r,e)=>(F(t).then(e).catch(n=>{console.error("[Singularity] Error handling message:",n),e({error:n.message})}),!0));async function F(t,r){const{action:e}=t;switch(e){case"extractContext":return await v(t.message);case"getRelevantContext":return await B(t.message,t.platform);case"getContextStats":return await D();case"toggleExtension":return await I(t.enabled);case"deleteFact":return await O(t.factId);case"clearAllContext":return await P();default:return{error:"Unknown action"}}}async function v(t){try{await p(t);const r=await fetch(`${g}/api/extract`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({message:t})});if(!r.ok)throw new Error("Backend extraction failed");const e=await r.json();if(e.facts&&e.facts.length>0){for(const n of e.facts)await h({...n,extractedAt:new Date().toISOString(),sourceMessage:t.text});console.log(`[Singularity] Stored ${e.facts.length} facts`)}return{success:!0,factsExtracted:e.facts.length}}catch(r){console.error("[Singularity] Context extraction failed:",r);const e=j(t);for(const n of e)await h(n);return{success:!0,factsExtracted:e.length,fallback:!0}}}function j(t){const r=[],e=t.text.toLowerCase(),n=[/i (?:like|love|prefer|enjoy) ([^.,!?]+)/gi,/i am (a |an )?([^.,!?]+)/gi,/my (?:favorite|favourite) ([^.,!?]+) is ([^.,!?]+)/gi];for(const c of n){const o=[...e.matchAll(c)];for(const a of o)r.push({text:a[0],category:"preference",confidence:.5,platform:t.platform,timestamp:t.timestamp})}return r}async function B(t,r){try{const e=await fetch(`${g}/api/retrieve`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({query:t,platform:r,limit:5})});if(!e.ok)throw new Error("Backend retrieval failed");return{context:(await e.json()).context||[]}}catch(e){return console.error("[Singularity] Context retrieval failed, using fallback:",e),{context:(await x()).filter(o=>{if(o.platform===r)return!1;const a=t.toLowerCase().split(" "),d=o.text.toLowerCase();return a.some(l=>l.length>3&&d.includes(l))}).slice(0,3).map(o=>o.text)}}}async function D(){try{const t=await C(),r=await b(50);return{count:t,recentFacts:r}}catch(t){return console.error("[Singularity] Failed to get stats:",t),{count:0,recentFacts:[]}}}async function I(t){await chrome.storage.local.set({enabled:t}),console.log(`[Singularity] Extension ${t?"enabled":"disabled"}`);const r=await chrome.tabs.query({});for(const e of r)try{await chrome.tabs.sendMessage(e.id,{action:"toggleExtension",enabled:t})}catch{}return{success:!0}}async function O(t){try{return await k(t),console.log(`[Singularity] Deleted fact with ID: ${t}`),{success:!0}}catch(r){return console.error("[Singularity] Failed to delete fact:",r),{success:!1,error:r.message}}}async function P(){try{await E(),console.log("[Singularity] IndexedDB context cleared");try{(await fetch(`${g}/api/clear`,{method:"POST",headers:{"Content-Type":"application/json"}})).ok?console.log("[Singularity] Backend cache cleared"):console.warn("[Singularity] Failed to clear backend cache")}catch(t){console.warn("[Singularity] Backend not available for cache clearing:",t)}return{success:!0}}catch(t){return console.error("[Singularity] Failed to clear context:",t),{success:!1,error:t.message}}}setInterval(async()=>{try{(await fetch(`${g}/health`,{method:"GET"})).ok&&console.log("[Singularity] Backend is healthy")}catch{console.log("[Singularity] Backend is not reachable")}},6e4);
